# МЕТАПАРСЕР 3

## Введение

### Чувство парсера

INSTEAD начался как проект, который пытался избежать подхода CYOA при
разработке текстовых квестов и привнести чувство игры как в "настоящем
приключении", но только в текстовом виде.

Как вы наверняка знаете, классические текстовые приключения -- это
парсерные игры, в которых моделируется мир, и герой исследует этот мир
под чутким управлением игрока, который описывает желаемые действия с
помощью клавиатуры. Тут и клавиатура и способ моделирования мира
работают на создание общей цели -- у игрока возникает чувство свободы
и загадки. Ты свободен перемещаться по миру, взаимодействовать с ним
-- в этом смысле такая игра и есть настоящая адвенчура (квест).

CYOA игры - это игры с управлением через меню, обычно сводящиеся к
выбору вариантов развития событий (убежать, показать пропуск охраннику
и т.д.) Здесь способ ввода и способ написания игры также направлены на
реализации своей цели. Игра обычно выглядит как сборник параграфов,
нередко описывающих целые сюжетные повороты, а не только (и не
сколько) локации (места действий, декорации) с переходами между
ними. В этом смысле, жанр таких игр больше тяготеет к книгам-играм,
хотя, конечно, многое зависит от конкретной игры.

Если же отойти от текстовых игр и посмотреть на классические
графические квесты (из золотого фонда Lucas Arts и Sierra), то там мы
увидим что-то среднее: либо глаголы, как в Monkey Island, либо
манипуляции предметами, как в Goblins, либо что-то смешанное. Тем не
менее, эти игры больше похожи на парсерные игры в том смысле, что
герой свободно исследует мир, а его способ взаимодействия с миром
носит условно свободный характер (набор универсальных действий,
свободная манипуляция предметами и т.д.) Фактически, это и есть
парсерные игры, которые перешли в графическую плоскость, заодно сильно
упростив способ ввода.

INSTEAD начинался как проект по созданию движка для игры, которая
будучи текстовой, по своему игровому процессу не сильно отличалась бы
от классических графических квестов. Такой первой игрой стала
"Возвращение квантового кота".

В этой игре был выбран упрощенный ввод в виде свободного
манипулирования предметами, что сильно снижало порог вхождения для
потенциального игрока, но вместе с тем оставляло поле для
свободы. Потом, по мере развития движка, появились игры с глагольным
меню, которые еще больше сблизили текстовые квесты с классикой
(правда, такие игры обычно обладали повышенной сложностью). В качестве
примеров таких игр можно назвать "Кайлет" (набор глаголов) и "Особняк"
(три глагола).

Тем не менее, мне было всегда интересно посмотреть, можно ли сблизить
игру с парсером еще теснее, при этом не сильно подняв порог вхождения?
Можно ли взять лучшее от INSTEAD подхода и парсера?

Кое-какой опыт по работе с парсером у меня был. Еще перед написанием
INSTEAD я изучал Inform и даже писал небольшую игру, поэтому я
примерно представлял проблемы и плюсы парсерной игры на русском языке.

Огромное преимущество парсерных игр -- глубокое погружение. Во время
игры, игрок вынужден читать и думать, это очень сильно отличается от
CYOA игр, и все-еще отличается от игр с глагольным меню. Именно эта
черта заставляла экспериментировать с игровым вводом. Однако, такие
игры сложнее писать, особенно на русском, и (что не менее важно) в них
не так просто играть!

Обычно, неявным образом подразумевается, что идеальный парсер -- это
ИИ, который понимает все, что напишет игрок. Это и сила и слабость
одновременно. Я не верю, что компьютер научится думать (по крайней
мере, в обозримом будущем), а это значит, что ИИ, который бы мог
учитывать в полной мере контекст введенных команд и вообще угадывать
то, что игрок хочет сделать в свободной разговорной форме --
утопия. Во всех существующих реализациях, парсер пытается притвориться
умным с разной степенью успешности, но любой парсер бессильно
проигрывает, когда за клавиатуру садится неподготовленный игрок,
который воображает, что игра поймет все, что он напишет.

Если же совместить это с богатством русского языка, то получится, что
в русские парсерные игры способны играть далеко не все, да и даже
подготовленный игрок с большой долей вероятности натолкнется на
ситуацию, где отсутствие привычного ему синонима отобьет всю охоту
заканчивать игру.

В этом смысле, подход реализации парсера как поиска по шаблонам, может
показаться перспективным. Суть его в том, что парсер не пытается
понять что именно ввел игрок, а просто реагирует на заведомо забитые в
него шаблоны игровой ситуации. Таким образом, задача игрока --
угадать, хотя бы приблизительно, что от него требуется, а задача
автора -- написать хорошие шаблоны. Реализация может быть разной, но
суть примерно такова. В качестве примера можно привести Adrift.

В какой-то момент я решил, что это хорошая идея и сделал свой концепт
парсера, основанного на шаблонах. К счастью, даже отрицательный
результат это результат. Мой концепт оказался провальным. Основные
недостатки шаблонного парсера:

  * игрок по прежнему думает, что парсер понимает все;
  * парсер слишком широко понимает игрока, в итоге возникают казусы,
    когда игрок получает совсем неожиданную реакцию на свои действия;
  * парсер не понимает ввод и вывод неудачных реакций не информативен;
  * писать игру очень сложно, так как не так просто написать
    правильные, непротиворечивые шаблоны

В общем, пришлось оставить эту идею. Однако, меня не покидала мысль,
что есть и другой путь. И действительно, этот путь нашелся!


Следующим проектом на пути к обретению чувства парсера стал --
"МЕТАПАРСЕР 2"

## МЕТАПАРСЕР 2

Я давно заметил, что с ростом числа глаголов в глагольном меню,
чувство игры начинает приближаться к парсерному варианту. Правда, при
этом возникали другие проблемы: захламление меню и все возрастающая
сложность написание игры (так как обработчики неудачных действий
ничего не знают о смысле действий, о падежных формах и вообще не
занимаются анализом, то в целях литературности приходится прописывать
реакции на все возможные действия). В тоже время, в парсере указанных
проблем нет.

Тогда меня внезапно посетила мысль о создании парсера, который
работает одновременно и на принципах меню и на принципах парсера, взяв
лучшее из обоих миров. Я подумал, что задачу абсолютной
непротиворечивости интеллекта парсера можно решить не за счет его
усложнения, а наоборот, за счет его упрощения. Другими словами, игрок
не может ввести действия, которые не будут поняты игрой, или же игрок
должен постоянно как-то понимать, понимает ли его игра в данный
момент.

Конечно, мой парсер должен был быть оформлен как модуль INSTEAD, тем
самым давая возможности использовать весь накопленный багаж его
функций, примерно также как в ситуации с другими модулями для
INSTEAD. Ввод же с клавиатуры был отлажен еще во время моей попытки
создания парсера на шаблонах.

К слову, забегая вперед, когда я рассказал (и показал прототип) своего
парсера другу, он предложил назвать его "квазипарсер". В каком-то
смысле это точное определение, так как мой парсер не обладает никаким
интеллектом, тем не менее я назвал его "метапарсер", так как на мой
взгляд, он обладает теми приемуществами, которые я искал.

Итак, нужно было решить две проблемы.

Первая из проблем -- парсер должен уметь делать склонения, так как
настоящая парсерная игра предполагает десятки и сотни действий,
которые автор игры не обязан (да и не способен) прописывать
сам. Например, если в игре есть дверь и ее можно открыть и закрыть, то
движок сам в состоянии отреагировать на команды "открыть" или "закрыть
дверь" на основании указания, что объект "дверь" может
открываться. Или предметы, которые можно подбирать и бросать. Фразу -
"Я взял яблоко." вполне может сформировать и сам движок. Но гораздо
важнее, чтобы движок мог среагировать на непрописанное действие,
навроде такого:

```
толкнуть Габриэллу
Габриэлле это не понравится!
```

На самом деле, чтобы научить движок склонять слова, можно пойти двумя
путями.

Первый путь, это при описании объекта четко описать его
характеристики: число, род, одушевленность. Выделить окончание, и
воспользоваться алгоритмом для формирования склонений. У такого
подхода есть пару существенных недостатков:

  * алгоритм склонений не универсален;
  * код игры становится сложным, высокий порог вхождения для автора
    игры.

Второй путь, это использование словаря. В этом случае, для описания
объекта только иногда необходимо указать одушевленность, и все. Тем не
менее у этого подхода есть свои недостатки:

  * объем словаря велик;
  * иногда, в словаре может не быть нужного слова.

Я не пошел по пути алгоритма, главным образом потому, что это сильно
затрудняет написание игры (я помнил это еще по моим экспериментом с
Inform). В итоге, в метапарсере я использовал словарь, взяв за основу
базу с http://aot.ru. К счастью, формат словаря оказался
понятным. Кроме того, я нашел его черновое описание, и в итоге, мне
удалось сконвертировать его для удобного распознавания изнутри
lua. Фактически, за пару недель, решение проблемы склонений было
найдено! Словарь в UTF-8 кодировке занимает около 8МБ и для повышения
скорости и снижения объемов игры был выбран путь компиляции словаря
для конкретной игры. В итоге, получаемый словарь был очень маленьким и
быстрым, так как содержал только то, что нужно.

Результат мне очень понравился, ситуации, когда словарь срабатывал
неправильно можно пересчитать по пальцам, кроме того, всегда можно
было вписать свои варианты склонений (например, имя Габриэллы).

Осталось сделать совсем немного -- сам парсер. :)

Идея была в следующем. Парсер понимает некий набор глаголов, с
переменным числом параметров. Например, можно написать:

```
бросить лампу в гоблина
```

или просто:

```
бросить лампу
```

Оба действия -- это действие "бросить", но в одном случае мы бросаем
лампу в гоблина, а во вторую - избавляемся от нее. Погружаться в
детали пока не будем, но суть в том, что парсер всегда знает множество
того, что может ввести игрок. То-есть метапарсер в каком-то смысле
обратен парсеру. Он не пытается понять, что пишет игрок -- он знает
что вообще можно написать и следит, какую из веток набирает сейчас
игрок.

Такое устройство парсера означает, что в любой момент времени он может
подсказать игроку возможные варианты, например, игрок пишет:


```
бросить л_
```

В этот момент парсер знает, что игрок хочет написать какое-то слово,
которое начинается на букву л и это предмет из сцены или инвентаря,
парсер может _подсказать_.

Подсказки выводятся в каждый момент времени в виде списка слов,
которые можно продолжать набирать, или по которым можно щелкать
мышкой. Это приводит к тому, что в метапарсер можно играть без

На МЕТАПАРСЕРЕ 2 было написано несколько игр, и я считал его своим
успешным проектом, но все-таки меня не оставляла мысль о том, что
можно пойти еще дальше...

### МЕТАПАРСЕР 3

Я хотел понять, а можно ли совместить удачные идеи от МЕТАПАРСЕРА 2 с
настоящим парсером? Так появился МЕТАПАРСЕР 3.

Итак, в отличие от своего предшественника МЕТАПАРСЕР 3 это настоящий
парсер. Это значит, что если отключить подсказки в виде ссылок - слов
игра играется так же как игры на информе. Можно написать: взять
яблоко, или яблоко взять или быстро возьми яблоко и это будет работать

Словарь теперь используется на полную катушку. в том числе и для
глаголов. Это очень сильно упростило код самого движка.  Пример вывода
стандартной библиотеки;


```
mp.msg.Enter.INV = "{#Me} не {#word/могу,#me,нст} зайти в то, что {#word/держать,#me,нст} в руках."
```

МЕТАПАРСЕР 3 написан на stead3 -- код стал понятным и простым для
расширения. Код игр _значительно упрощен_.

В МЕТАПАРСЕР 3 использована стандартная библиотека, которая была
позаимствована из Inform6. Это очень облегчает моделирование мира
игры. Например, можно поставить стол, на нем аквариум (прозрачный и
открытый) В нем рыбка. И все будет корректно отрабатывать - включая
зоны видимости.

Парсер чуток к игроку. Например, он понимает описки в словах и
указывает на них. Подсказывает варианты ввода.

При этом МЕТАПАРСЕР 3 может работать в режиме своего предшественника,
в таком случае варианты слов подсвечиваются в виде списка и их можно
выбирать мышкой.

Итак, остался только один вопрос. Можно ли сегодня написать
парсер, в который будут играть?

## Быстрый старт

Перед тем как писать игры на МЕТАПАРСЕРЕ3 вам желательно ознакомиться
с STEAD3 и понимать общие принципы программирования игр на INSTEAD.

Для того, чтобы начать свою игру, вам необходимо скачать последнюю
версию МЕТАПАРСЕРА (далее МП), который, кроме всего прочего, содержит в себе
словарь. На данный момент МП можно взять из репозитория
модулей инстед: https://github.com/instead-hub/stead3-modules

Модули МП расположены в подкаталоге metaparser.

В каталоге metaparser/demos есть несколько демонстрационных игр. Вы
можете скопировать любую игру (файл main3.lua) в каталог metaparser/ и
запустить ее.

Самая простая игра -- heidi. Вы можете изучить ее исходный код и
использовать ее как шаблон.

## Скелет игры

В качестве примера я буду рассматривать игру heidi. Итак, заготовка
игры:

```
--$Name:Хейди$
require "mp-ru" -- подключаем модули МП
require "fmt" -- форматирование

game.dsc = [[^Пример простой игры на Inform.
^Авторы: Роджер Фирт (Roger Firth) и Соня Кессерих (Sonja Kesserich).
^Перевод Юрия Салтыкова a.k.a. G.A. Garinson^
^Перевод на МЕТАПАРСЕР 3 выполнил Петр Косых.
^
]]

```

Собственно говоря, это все. Такую игру уже можно запустить. Обратите
внимание на game.dsc -- это тот текст, который выводится перед началом
игры. Конечно, game.dsc может быть функцией.


## Словарь

Прежде чем мы начнем создавать мир игры нужно отметить следующую
вещь. Как уже было сказано во введении, МП3 использует словарь.

Полный словарь (> 8Мб) расположен в metaparser/morph/morphs.mrd. При
запуске игры движок смотрит за изменением словарного состава игры и
_компилирует_ персональный (маленький) словарь для конкретной
игры. Этот словарь будет расположен в metaparser/dict.mrd.

Компиляция словаря может быть длительным процессом на слабых
машинах. Например, на eeepc время компиляции около 20 секунд. На i3 --
около 7 секунд. Если вы Unix пользователь я рекомендую собрать INSTEAD
с luajit, таким образом вы ускорите время компиляции словаря в 2
раза.

Компиляция происходит тогда, когда в код игры добавляются или
удаляются словарные слова (об этом будет сказано далее).

_ВНИМАНИЕ_: Когда ваша игра готова, вы можете стереть файл полного
словаря metaparser/morph/morphs.mrd. Это действительно стоит сделать,
так как размер готовой игры уменьшится на 8Мб.

## Комнаты и объекты

Давайте добавим комнату в игру.


```
room {
	nam = "before_cottage";
	title = "Перед домом";
	dsc = "Ты стоишь около избушки, на восток от которой раскинулся лес.";
}

```

Здесь пока все понятно и соответствует STEAD3 API. Теперь, чтобы наша
игра начиналась с этой локации, а не из комнаты main, добавим функцию
init:


```
function init()
	pl.room = 'before_cottage'
	-- то же самое можно было бы записать так:
	-- me().room = 'before_cottage'
end

```

Теперь, если запустить игру, то мы окажемся в локации "Перед домом".

Что дальше? Добавляем объект.


```
obj {
	-"домик";
	nam = "cottage";
	dsc = "Домик мал и неказист, но ты очень счастлива, живя здесь.";
}

```

Здесь мы видим определение словарных слов. Модуль словаря при запуске
игры ищет в *.lua файлах строчки вида

```
-"что то"
```

И считает из словарными словами, для которых нужно создать запись в
персональном словаре игры. Таким образом, вы можете добавлять слова
просто используя комментарии:

```
--"бутылка"
```

На самом деле, в стандартной библиотеке используется этот прием.

Но при создании объектов мы делаем две вещи сразу:

1) определяем имя объекта, по которому его видит игрок;
2) определяем факт того, что это словарное слово.

Чтобы более подробно пояснить этот факт, приведу пример:


```
--"домик"
obj {
	word = "домик";
	nam = "cottage";
	dsc = "Домик мал и неказист, но ты очень счастлива, живя здесь.";
}

```

На самом деле мы сделали тоже самое. Определили отображаемое имя через
word = и определили словарные слова, но гораздо проще запись, которая
делает эти две вещи сразу:

```
obj {
	-"домик";
	nam = "cottage";
```

Теперь добавим объект в сцену. В МП3 мы можем сделать это несколькими
способами.

Через задание obj у комнаты:

```
room {
	nam = "before_cottage";
...
	obj = { 'cottage' };
}
```

Через :with у комнаты:

```
room {
	nam = "before_cottage";
...
}: with {'cottage'}
```

Через задание found_in у объекта:


```
obj {
	-"домик";
	nam = "cottage";
	found_in = 'before_cottage';
-- или found_in = { 'before_cottage' }
```

Если вы запустите игру, произойдет генерация словаря а затем вы
сможете, например, ввести команду: осмотреть домик и получить ответ:
ты не видишь в домике ничего необычного.

Как видим, слово "домик" попало в словарь и успешно склоняется движком.

Но что если вы наберете: осмотреть дом? Увы, игра вас не поймет.

## Подробнее о словарных словах

Итак, задавая словарное слово в виде: -"домик" мы определили основное
словарное слово. Если вы считаете (а обычно это так), что предмет
может быть доступен по нескольким именам, у вас есть следующие
возможности:

Перечислить варианты через запятую. Внимание! Этот метод работает,
если род и число синонимов совпадают. Например:

```
-"домик,дом"
```

При этом в словарь будут добавлены оба слова. Основным словом
останется _домик_, а _дом_ будет дополнительным синонимом. Так, если
игрок напишет: осмотреть дом, то получит сообщение: ты не видишь в
домике ничего необычного.

Хорошо, но что если мы хотим, чтобы игра откликалась и на избушку?

Если мы напишем:

``
-"домик,дом,избушка"
``

Движок не сможет корректно склонять слова, так как слова имеют разный
род. В таком случае можно воспользоваться альясами:


``
-"домик,дом|избушка"
``

Альяс -- это полноценное альтернативное имя объекта. Например, если
игрок напишет: осмотреть избушку, то получит: ты не видишь в избушке
ничего интересного.

На самом деле есть еще один простой способ заставить игру понимать
слово избушка. Этот способ -- шаблоны. Например:


``
-"домик,дом,избуш*"
``

При этом, если игрок введет что угодно, начинающееся с избуш -- игра
воспримет это как сионим домика. Отличия шаблонов от полноценных слов:

1) шаблоны не могут быть 1-ми в списке;
2) шаблоны не автодополняются по клавише TAB;
3) шаблоны не могут быть подсказаны движком.

Использовать шаблоны имеет смысл в каких то сложных случаях как
дополнительное средство, например:

```
-"домик,дом|избушка,избу*,терем*,коттедж*,хат*,строени*";
```

Обычно словарь сам справляется с определением рода, числа и даже
одушевленности, однако иногда возникают спорные ситуации, когда одно и
то же слово может означать, например, фамилию или качество объекта. В
таких случаях вы можете уточнять словарное слово, например:

```
-"домик,дом/мр,ед"
```

Уточнения всегда относятся к одному слову или группе слов, разделенных
запятыми. Например:

```
-"домик,дом/мр,ед" -- правильно
-"домик/мр,дом/мр" -- неправильно
-"домик,дом/мр|избушка/жр" -- правильно
```

Список уточнений:

- мр - мужской род;
- жр - женский род;
- мн - множественное число;
- ед - единственное число;
- од - одушевленное;

Для комбинации уточнений, используйте запятую.
Для отрицания, можно использовать символ ~. Например:

```
-"фрукты/~од"
```

На самом деле, уточнения нужны редко. Используйте их только для
проблемных слов.

В качестве словарных слов вы можете использовать несколько слов,
например:

```
-"черный котенок,котенок/мр"
```

В таком случае, обязательно делайте наиболее полным первое -- основное
описание, а затем указывайте сокращенный вариант. Тогда игрок сможет
обратиться и к котенку и к черному котенку. А если на сцене будет
несколько котят, то движок сможет сделать подсказку.

Иногда может оказаться, что слова нет даже в полном словаре (или оно
неверно склоняется). Например, какая то экзотическая фамилия, или
вымышленное слово. В таком случае, придется добавить его в словарь
вручную.

У вас есть две возможности: добавить слово в словарь объекта или в
словарь игры.

Добавление словарного слова в словарь объекта:


```
obj {
	-"герцог|Гесслер,фогт,Герман";
	nam = 'governor';
...
} : dict {
	["Гесслер/вн"] = "Гесслера";
	["Гесслер/рд"] = "Гесслера";
	["Гесслер/дт"] = "Гесслеру";
	["Гесслер/тв"] = "Гесслером";
	["Гесслер/пр"] = "Гесслере";
}
```

Или словарь игры:


```
game : dict {
	["Гесслер/вн"] = "Гесслера";
	["Гесслер/рд"] = "Гесслера";
	["Гесслер/дт"] = "Гесслеру";
	["Гесслер/тв"] = "Гесслером";
	["Гесслер/пр"] = "Гесслере";
}

```

Ну и наконец, даже комнаты могут иметь словарное слово. Например:

```
room {
	-"двор,дворик,лес*";
	nam = "before_cottage";
	title = "Перед домом";
	dsc = "Ты стоишь около избушки, на восток от которой раскинулся лес.";
}
```

Игрок сможет написать: осмотреть двор, уйти со двора, осмотреть лес.

Но задавать словарное слово комнатам необязательно.

## Атрибуты

Если попробовать запустить нашу игру игру с локацией и домом в ней, то
в целом она будет выглядеть вполне адекватной. До тех пор, пока вы не
возьмете дом командой: взять домик.

Дело в том, что все объекты по умолчанию могут быть взяты.

Модель мира МП3 заимствована из Inform 6 и предполагает наличие у
объекта специальных атрибутов, которые меняют его поведение.

Для задания атрибутов используется метод :attr. Например:


```
obj {
	-"домик,дом";
	nam = "cottage";
	found_in = 'before_cottage';
}:attr 'scenery'
```

В данном примере мы присвоили домику атрибут scenery, который означает
следующее:

- описание предмета не нужно выводить после описания сцены;
- предмет не может быть взят, он является декорацией.

Попробуйте запускать варианты игр в которых атрибут scenery задан и не
задан и вы увидите, что когда scenery не задан, в описании игровой
ситуации после описания сцены присутствует строчка: Здесь находится
домик. Но когда мы задаем атрибут scenery эта строка
пропадает. Действительно, мы ведь уже описали домик в тексте
комнаты. Таким образом, атрибут scenery используется главным образом
для декораций.

Вы можете задавать несколько атрибутов, разделяя их
запятыми. Например:

```
}:attr 'scenery,supporter'
```

Вы можете динамически задавать атрибуты в коде:

```
_'cottage':attr 'scenery'
```

Или снимать их:


```
_'cottage':attr '~scenery'
```

А также проверять на их наличие:

```
-- по имени
if _'cottage':has'scenery' then ...

-- по параметру в обработчике
... = function(s, w)
	if w:has'scenery' then
```

Аттрибутов существует множество, пока опишем несколько:

- scenery -- объект является декорацией;
- static -- объект статичен, зафиксирован. Его нельзя брать, но
  описание его присутствует после описания сцены;
- concealed -- объект обычный, но его описание скрыто (в инвентаре и
  сцене);
- light -- освещено. В МП3 по умолчанию все комнаты имеют свет. Если
  вам нужна комната без света, при создании задайте :attr '~light'


## Свойства

Если игрок попробует осмотреть домик, он получит стандартное сообщение
библиотеки, которое не очень захватывает воображение.

Вы можете определить свойство description, которое будет содержать
сообщение при осмотре объекта:

```
obj {
	-"домик,дом|избушка,избу*,терем*,коттедж*,хат*,строени*";
	nam = "cottage";
	description = "Домик мал и неказист, но ты очень счастлива, живя здесь.";
}:attr 'scenery'

```

Конечно, description может быть функцией.

Выше мы уже использовали другое свойство: dsc. Это свойство отвечает
за то, как информация об объекте представлена в сцене. Для комнат это
будет описанем комнаты. Для обычных объектов -- их описанием в
сцене. Например, мы можем убрать scenery (заменив его static) и задать
dsc у домика:


```
obj {
	-"домик,дом|избушка,избу*,терем*,коттедж*,хат*,строени*";
	nam = "cottage";
	description = "Домик мал и неказист, но ты очень счастлива, живя здесь.";
	dsc = "Ты находишься в тени домика.";
}:attr 'static'
```

Описание "Ты находишься в тени домика." будет выведено после описания
комнаты.

Существует множество свойств, которые мы будем постепенно
рассматривать. А пока, создадим остальные локации.

## Стороны света

Мы создали только одну локацию. Обычно игра состоит из нескольких
локаций, связанных между собой. Традиционно, для ориентирования и
перемещения между локациями в адвенчурах используются стороны
света. Таким образом, локации связываются с учетом сторон света.

Например:

```
room {
	nam = "before_cottage";
	title = "Перед домом";
	dsc = "Ты стоишь около избушки, на восток от которой раскинулся лес.";
	e_to = 'forest';
}

room {
	-"чаща|лес";
	nam = "forest";
	title = "В лесной чаще";
	dsc = [[На западе, сквозь густую листву, можно разглядеть небольшое строение.^
            Тропинка ведет на северо-восток.]];
	w_to = 'before_cottage';
}
```

Здесь мы видим две локации. В локации "Перед домом" нам доступен
переход на восток (это отражено в тексте локации). При этом, если мы
пойдем на восток -- мы попадем в лес. Вы уже заметили, что комнаты
связаны с помощью свойст e\_to (путь на восток) и w\_to(путь на
запад).

В МП3 как и в Inform 6 определены 8 горизонтальных направлений.

1) n\_to на север
2) ne\_to на северо-восток
3) e\_to на восток
4) se\_to на юго-восток
5) s\_to на юг
6) sw\_to на юго-запад
7) w\_to на запад
8) nw\_to на северо-запад

Два вертикальных направления:

1) u\_to вверх
2) d\_to вниз

И два дополнительных:

1) in\_to внутрь
2) out\_to наружу

Все эти свойства могут быть как строками (и содержать nam
комнат-направлений), так и функциями. Во втором случае, при попытке
перехода по заданному направлению будет выполнена эта функция.

Если в вашей игре вам не нужен компас, просто отключите его:

```
disable '@compass'
```

Когда у комнаты нет какого-либо направления, а игрок пытается идти в
этом направлении, библиотека выдает стандартное сообщений. Если вы
зададите у комнаты свойство cant\_go, то это свойство будет выполнено
в данной ситуации.


```
room {
	nam = "before_cottage";
	title = "Перед домом";
	dsc = "Ты стоишь около избушки, на восток от которой раскинулся лес.";
	e_to = 'forest';
	in_to = function() p "Такой славный денек... Он слишком хорош, чтобы прятаться внутри."; end;
	cant_go = "Единственный путь ведет на восток.";
}

```
Обратите внимание, что свойство in\_to задано в виде функции. Если бы
это была просто строка, движок бы попытался найти комнату с таким
nam. Теперь же, если игрок напишет: идти внутрь, ему будет показано
наше сообщение.

## Добавляем новые объекты

В игре Хейди мы должны будем спасти птенчика выпавшего из гнезда. Вот
как определяются птенчик:


```
obj {
	-"птенчик,птенец|птица,птичка|детёныш";
	nam = "bird";
	description = "Слишком мал, чтобы летать, птенец беспомощно попискивает.";
	before_Listen = "Жалобный писк испуганной птички разрывает тебе сердце.^Надо помочь!";
}: attr '~animate'

```

Здесь нам многое уже знакомо. Описаны словарные слова. Задано свойство
description. Но есть и новые вещи.

Во первых, отменяется атрибут animate. animate это признак того, что
персонаж является живым персонажем игры. В МП3 используется словарь,
который обычно автоматически считает все одушевленные объекты
персонажами. Но почему мы отменяем это в данном случае? Дело в том,
что стандартная библиотека по умолчанию не дает брать персонажей. А
птенчика мы должны уметь забрать, так что в данном случае признак
персонажа нам мешает. Попробуйте убрать отмену атрибута animate и
посмотреть, что скажет игра на попытку взять птенчика.
